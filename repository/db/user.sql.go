// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package db

import (
	"context"
)

const findUserById = `-- name: FindUserById :one
select id, role_id, auth_key, login_id, password_hash, username, mailaddress, authority_level, last_logedin_at, view_order, is_deleted, created_by, created_at, updated_by, updated_at
from m_user mu 
where id = $1
`

func (q *Queries) FindUserById(ctx context.Context, id int64) (MUser, error) {
	row := q.db.QueryRow(ctx, findUserById, id)
	var i MUser
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.AuthKey,
		&i.LoginID,
		&i.PasswordHash,
		&i.Username,
		&i.Mailaddress,
		&i.AuthorityLevel,
		&i.LastLogedinAt,
		&i.ViewOrder,
		&i.IsDeleted,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserAll = `-- name: GetUserAll :many
select id, role_id, auth_key, login_id, password_hash, username, mailaddress, authority_level, last_logedin_at, view_order, is_deleted, created_by, created_at, updated_by, updated_at
from m_user mu
`

func (q *Queries) GetUserAll(ctx context.Context) ([]MUser, error) {
	rows, err := q.db.Query(ctx, getUserAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MUser
	for rows.Next() {
		var i MUser
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.AuthKey,
			&i.LoginID,
			&i.PasswordHash,
			&i.Username,
			&i.Mailaddress,
			&i.AuthorityLevel,
			&i.LastLogedinAt,
			&i.ViewOrder,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tryLogin = `-- name: TryLogin :one
select id, role_id, auth_key, login_id, password_hash, username, mailaddress, authority_level, last_logedin_at, view_order, is_deleted, created_by, created_at, updated_by, updated_at
from m_user	mu
where login_id = $1
and mu.password_hash = $2
and mu.is_deleted = false
`

type TryLoginParams struct {
	LoginID      string `db:"login_id" json:"loginId"`
	PasswordHash string `db:"password_hash" json:"passwordHash"`
}

func (q *Queries) TryLogin(ctx context.Context, arg TryLoginParams) (MUser, error) {
	row := q.db.QueryRow(ctx, tryLogin, arg.LoginID, arg.PasswordHash)
	var i MUser
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.AuthKey,
		&i.LoginID,
		&i.PasswordHash,
		&i.Username,
		&i.Mailaddress,
		&i.AuthorityLevel,
		&i.LastLogedinAt,
		&i.ViewOrder,
		&i.IsDeleted,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}
